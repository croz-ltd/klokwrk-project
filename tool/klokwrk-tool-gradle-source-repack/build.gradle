/*
 * SPDX-License-Identifier: Apache-2.0
 *
 * Copyright 2020-2022 CROZ d.o.o, the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.tools.ant.filters.ReplaceTokens
import org.gradle.internal.deprecation.DeprecatableConfiguration

plugins {
  id "klokwrk-gradle-plugin-convention-module-base"
  id "klokwrk-gradle-plugin-convention-module-groovy"
  id "klokwrk-gradle-plugin-convention-micronaut-app"
}

config {
  coverage {
    jacoco {
      setExcludes(["org/klokwrk/tool/gradle/source/repack/graal/**"] as Set<String>)
    }
  }
}

micronaut {
  testRuntime("spock2")
  enableNativeImage(false)
  processing {
    incremental(true)
    annotations("org.klokwrk.tool.gradle.source.repack.*")
  }
}

application {
  mainClass.set("org.klokwrk.tool.gradle.source.repack.GradleSourceRepackCommand")
}

// Processes resources/version.properties and replaces tokens with provided values.
processResources {
  filteringCharset = "UTF-8"
  filter(ReplaceTokens, tokens: [moduleName: project.name, moduleVersion: project.version])
}

configurations {
  graalNativeImageDependencies
}

dependencies {
  graalNativeImageDependencies platform(project(":klokwrk-platform-base"))
  implementation platform(project(":klokwrk-platform-micronaut"))

  graalNativeImageDependencies "io.github.classgraph:classgraph"

  compileOnly "info.picocli:picocli-codegen"
  compileOnly "io.github.classgraph:classgraph"
  compileOnly "org.graalvm.nativeimage:svm"

  implementation "info.picocli:picocli"
  implementation "io.micronaut:micronaut-core"
  implementation "io.micronaut:micronaut-http-client-core"
  implementation "io.micronaut.picocli:micronaut-picocli"
  implementation "io.micronaut.reactor:micronaut-reactor-http-client"
  implementation "jakarta.inject:jakarta.inject-api"
  implementation "org.codehaus.groovy:groovy"
  implementation "org.slf4j:slf4j-api"

  testImplementation "com.github.tomakehurst:wiremock-jre8"
  testImplementation "com.google.jimfs:jimfs"
  testImplementation "ch.qos.logback:logback-classic"

  runtimeOnly "ch.qos.logback:logback-classic"
}

Boolean isWindows() {
  return System.getProperty("os.name").toLowerCase().contains("windows")
}

// Simple custom graal image builder task used because of some bugs/missing features in Micronaut task.
// Can be replaced by the Micronaut's one when at least the first of the following bugs is fixed:
// - https://github.com/micronaut-projects/micronaut-gradle-plugin/issues/92
// - https://github.com/micronaut-projects/micronaut-gradle-plugin/issues/93
//
// In addition there is also an issue with missing resources in Micronaut task that causes native image build failing in the presence of both java and groovy source sets. Didn't reported that yet,
// but I guess it will not get much attention since native image for Groovy is not supported.
tasks.register("kwrkNativeImage", Exec) { Exec thisExecTask ->
  def shadowJar = project.tasks.findByName("shadowJar")
  thisExecTask.dependsOn shadowJar

  String nativeImageBuilderClasspath = null
  project.configurations { ConfigurationContainer configurationContainer ->
    Set<Configuration> filteredConfigurations = configurationContainer
        .findAll({ Configuration configuration ->
          if (configuration instanceof DeprecatableConfiguration) {
            DeprecatableConfiguration deprecatableConfiguration = (DeprecatableConfiguration) configuration
            if (deprecatableConfiguration.resolutionAlternatives != null) {
              return false
            }
          }

          return true
        })
        .findAll { Configuration configuration ->
          return configuration.canBeResolved
        }
        .findAll({ Configuration configuration ->
          return ["graalNativeImageDependencies"].contains(configuration.name)
        })

    Set<File> resolvedDependencies = filteredConfigurations.collectMany { Configuration configuration -> configuration.resolve() }
    nativeImageBuilderClasspath = project.files(resolvedDependencies, shadowJar.archiveFile as RegularFile).asPath

    return
  }

  File workingDir = new File(project.buildDir, "native-image")
  workingDir.mkdirs()

  JavaApplication javaApplication = project.extensions.getByType(JavaApplication)
  String mainClass = javaApplication.getMainClass().get()

  File mainGraalSourceSetDir = new File(project.projectDir, "src/main/graal")

  String executable = isWindows() ? "native-image.cmd" : "native-image"
  thisExecTask.setExecutable(executable)
  thisExecTask.setWorkingDir(workingDir)
  thisExecTask.setArgs([
      // Enables verbose output that display full configuration used for creating a native image.
      "--verbose",

      // A separated list of directories, JAR archives, and ZIP archives to search for class files.
      "--class-path=$nativeImageBuilderClasspath",

      // Allow image building with an incomplete class path. Report type resolution errors at runtime when they are accessed the first time, instead of during image building.
      //
      // Some parts of Groovy core (inside groovy-*.jar) are designed to be initialized when accessed at runtime for the first time. At the same time, those Groovy parts expects that
      // corresponding dependencies are available at classpath.
      // Even if these core Groovy parts are not used from application, they are still reachable during GraalVM static analysis and it complains about missing dependencies. Therefore, we need to
      // allow for incomplete classpath if we do not want native image compilation to fail and stop.
      //
      // Further, when encountering missing dependencies, GraalVM static analysis will complain with warnings. To eliminate warnings, incriminating Groovy classes needs to be added under
      // "initialize-at-run-time" option.
      "--allow-incomplete-classpath",

      // Report usage of unsupported methods and fields at runtime when they are accessed the first time, instead of as an error during image building.
      //
      // Necessary for compiling Groovy apps since Groovy core, even when statically compiled, still exposes many code paths used only with dynamic Groovy. Even if they are not used with statically
      // compiled Groovy, they are still reachable by GraalVM native image analysis. In some cases GraalVM native image compiler cannot reduce those multiple code paths to a single method call which
      // results with GraalVM UnsupportedFeatureException during native image compilation.
      "--report-unsupported-elements-at-runtime",

      // A comma-separated list of packages and classes (and implicitly all of their superclasses) that are initialized during image generation. An empty string designates all packages.
      // As of Graal 21.2, this list should not be empty (https://www.graalvm.org/release-notes/21_2/#native-image)
      "--initialize-at-build-time=".concat(String.join(",", [
          "com.sun.beans",
          "groovy.lang",
          "groovyjarjarantlr4.v4",
          "java.beans",
          "org.apache.groovy",
          "org.codehaus.groovy"
      ])),

      // A comma-separated list of packages and classes (and implicitly all of their subclasses) that must be initialized at runtime and not during image building. An empty string is currently not
      // supported.
      "--initialize-at-run-time=".concat(String.join(",", [
          "org.codehaus.groovy.control.XStreamUtils",
          "groovy.grape.GrapeIvy"
      ])),

      // Do not fallback on plain JVM when AOT native image compilation fails. Throw an error instead.
      "--no-fallback",

      // Comma separated list of directories containing GraalVM native image builder configuration files that are not part of the classpath. This directory may contain all four files configuration
      // files: jni-config.json, reflect-config.json, proxy-config.json and resource-config.json.
      "-H:ConfigurationFileDirectories=${ mainGraalSourceSetDir.absolutePath }",

//      // Enables creation of detailed reports about GraalVM code analysis.
//      "-H:+PrintAnalysisCallTree",
//
//      // Enables creation of detailed report about objects included in the native image heap.
//      "-H:+PrintImageObjectTree",
//
//      // Defines the path for GraalVM Dashboard (https://www.graalvm.org/docs/tools/dashboard/) dump file
//      "-H:DashboardDump=${ workingDir.absolutePath }/dashboard-dump",
//
//      // Three options bellow dump all available data in GraalVM Dashboard dump file.
////      "-H:+DashboardHeap", // This one causes error at the moment in my environment. If this is also your case, comment it out.
//      "-H:+DashboardCode",
//      "-H:+DashboardPointsTo",

      // Print stacktrace of underlying exceptions.
      "-H:+ReportExceptionStackTraces",

      // Default locale
      "-H:DefaultLocale=en",

      // Included locales (comma separated list)
      "-H:IncludeLocales=en",

      // The directory where the generated executable is placed.
      "-H:Path=${ workingDir.absolutePath }",

      // The class containing the default entry point method.
      "-H:Class=${ mainClass }",

      // The name of the executable file that is generated.
      "-H:Name=${ project.name }"
  ])
}
